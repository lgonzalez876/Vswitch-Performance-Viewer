"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var extension_composer_factory_1 = require("./extension-composer-factory");
var utils_1 = require("./utils");
var _ = require("lodash");
var fs = require("fs");
var glob = require("glob");
var jju = require("jju");
var jsonInPlace = require("json-in-place");
var loc = require("./loc");
var path = require("path");
var trace = require("../../../lib/trace");
var version = require("../../../lib/dynamicVersion");
var util_1 = require("util");
var fs_1 = require("fs");
var fsUtils_1 = require("../../../lib/fsUtils");
/**
 * Facilitates the gathering/reading of partial manifests and creating the merged
 * manifests (one for each manifest builder)
 */
var Merger = /** @class */ (function () {
    /**
     * constructor. Instantiates one of each manifest builder.
     */
    function Merger(settings) {
        this.settings = settings;
        this.manifestBuilders = [];
    }
    Merger.prototype.gatherManifests = function () {
        var _this = this;
        trace.debug("merger.gatherManifests");
        if (this.settings.manifestGlobs && this.settings.manifestGlobs.length > 0) {
            var globs = this.settings.manifestGlobs.map(function (p) { return (path.isAbsolute(p) ? p : path.join(_this.settings.root, p)); });
            trace.debug("merger.gatherManifestsFromGlob");
            var promises = globs.map(function (pattern) {
                return new Promise(function (resolve, reject) {
                    glob(pattern, function (err, matches) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve(matches);
                        }
                    });
                });
            });
            return Promise.all(promises)
                .then(function (results) { return _.uniq(_.flatten(results)); })
                .then(function (results) {
                if (results.length > 0) {
                    trace.debug("Merging %s manifests from the following paths: ", results.length.toString());
                    results.forEach(function (path) { return trace.debug(path); });
                }
                else {
                    throw new Error("No manifests found from the following glob patterns: \n" + _this.settings.manifestGlobs.join("\n"));
                }
                return results;
            });
        }
        else {
            var manifests = this.settings.manifests;
            if (!manifests || manifests.length === 0) {
                return Promise.reject("No manifests specified.");
            }
            this.settings.manifests = _.uniq(manifests).map(function (p) { return (path.isAbsolute(p) ? p : path.join(_this.settings.root, p)); });
            trace.debug("Merging %s manifest%s from the following paths: ", manifests.length.toString(), manifests.length === 1 ? "" : "s");
            manifests.forEach(function (path) { return trace.debug(path); });
            return Promise.resolve(this.settings.manifests);
        }
    };
    Merger.prototype.loadManifestJs = function () {
        trace.debug("merger.manifestJs");
        // build environment object from --env parameter
        var env = {};
        (this.settings.env || []).forEach(function (kvp) {
            var _a = kvp.split('='), key = _a[0], value = _a.slice(1);
            env[key] = value.join('=');
        });
        var fullJsFile = path.resolve(this.settings.manifestJs);
        var manifestModuleFn = require(fullJsFile);
        if (!manifestModuleFn || typeof manifestModuleFn != "function") {
            throw new Error("Missing export function from manifest-js file " + fullJsFile);
        }
        var manifestData = manifestModuleFn(env);
        if (!manifestData) {
            throw new Error("The export function from manifest-js file " + fullJsFile + " must return the manifest object");
        }
        return manifestData;
    };
    /**
     * Finds all manifests and merges them into two JS Objects: vsoManifest and vsixManifest
     * @return Q.Promise<SplitManifest> An object containing the two manifests
     */
    Merger.prototype.merge = function () {
        return __awaiter(this, void 0, void 0, function () {
            var overridesProvided, manifestPromises, result, manifestFiles;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trace.debug("merger.merge");
                        overridesProvided = false;
                        manifestPromises = [];
                        if (!this.settings.manifestJs) return [3 /*break*/, 1];
                        result = this.loadManifestJs();
                        result.__origin = this.settings.manifestJs; // save the origin in order to resolve relative paths later.
                        manifestPromises.push(Promise.resolve(result));
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.gatherManifests()];
                    case 2:
                        manifestFiles = _a.sent();
                        manifestFiles.forEach(function (file) {
                            manifestPromises.push(util_1.promisify(fs_1.readFile)(file, "utf8").then(function (data) {
                                var jsonData = data.replace(/^\uFEFF/, "");
                                try {
                                    var result = _this.settings.json5 ? jju.parse(jsonData) : JSON.parse(jsonData);
                                    result.__origin = file; // save the origin in order to resolve relative paths later.
                                    return result;
                                }
                                catch (err) {
                                    trace.error("Error parsing the JSON in %s: ", file);
                                    trace.debug(jsonData, null);
                                    throw err;
                                }
                            }));
                        });
                        _a.label = 3;
                    case 3:
                        // Add the overrides if necessary
                        if (this.settings.overrides) {
                            overridesProvided = true;
                            manifestPromises.push(Promise.resolve(this.settings.overrides));
                        }
                        return [2 /*return*/, Promise.all(manifestPromises).then(function (partials) {
                                // Determine the targets so we can construct the builders
                                var targets = [];
                                partials.forEach(function (partial) {
                                    if (_.isArray(partial["targets"])) {
                                        targets = targets.concat(partial["targets"]);
                                    }
                                });
                                _this.extensionComposer = extension_composer_factory_1.ComposerFactory.GetComposer(_this.settings, targets);
                                _this.manifestBuilders = _this.extensionComposer.getBuilders();
                                var updateVersionPromise = Promise.resolve(null);
                                partials.forEach(function (partial, partialIndex) {
                                    // Rev the version if necessary
                                    if (_this.settings.revVersion) {
                                        if (partial["version"] && partial.__origin) {
                                            try {
                                                var parsedVersion = version.DynamicVersion.parse(partial["version"]);
                                                var newVersion = version.DynamicVersion.increase(parsedVersion);
                                                var newVersionString_1 = newVersion.toString();
                                                partial["version"] = newVersionString_1;
                                                updateVersionPromise = util_1.promisify(fs_1.readFile)(partial.__origin, "utf8").then(function (versionPartial) {
                                                    try {
                                                        var newPartial = void 0;
                                                        if (_this.settings.json5) {
                                                            var parsed = jju.parse(versionPartial);
                                                            parsed["version"] = newVersionString_1;
                                                            newPartial = jju.update(versionPartial, parsed);
                                                        }
                                                        else {
                                                            newPartial = jsonInPlace(versionPartial).set("version", newVersionString_1).toString();
                                                        }
                                                        return util_1.promisify(fs_1.writeFile)(partial.__origin, newPartial);
                                                    }
                                                    catch (e) {
                                                        trace.warn("Failed to lex partial as JSON to update the version. Skipping version rev...");
                                                    }
                                                });
                                            }
                                            catch (e) {
                                                trace.warn("Could not parse %s as a version (e.g. major.minor.patch). Skipping version rev...", partial["version"]);
                                            }
                                        }
                                    }
                                    // Transform asset paths to be relative to the root of all manifests, verify assets
                                    if (_.isArray(partial["files"])) {
                                        partial["files"].forEach(function (asset) {
                                            var keys = Object.keys(asset);
                                            if (keys.indexOf("path") < 0) {
                                                throw new Error("Files must have an absolute or relative (to the manifest) path.");
                                            }
                                            var absolutePath;
                                            if (path.isAbsolute(asset.path)) {
                                                absolutePath = asset.path;
                                            }
                                            else {
                                                absolutePath = path.join(path.dirname(partial.__origin), asset.path);
                                            }
                                            asset.path = path.relative(_this.settings.root, absolutePath);
                                        });
                                    }
                                    // Transform icon paths as above
                                    if (_.isObject(partial["icons"])) {
                                        var icons_1 = partial["icons"];
                                        Object.keys(icons_1).forEach(function (iconKind) {
                                            var absolutePath = path.join(path.dirname(partial.__origin), icons_1[iconKind]);
                                            icons_1[iconKind] = path.relative(_this.settings.root, absolutePath);
                                        });
                                    }
                                    // Expand any directories listed in the files array
                                    if (_.isArray(partial["files"])) {
                                        for (var i = partial["files"].length - 1; i >= 0; --i) {
                                            var fileDecl = partial["files"][i];
                                            var fsPath = path.join(_this.settings.root, fileDecl.path);
                                            if (fs.lstatSync(fsPath).isDirectory()) {
                                                Array.prototype.splice.apply(partial["files"], [i, 1].concat(_this.pathToFileDeclarations(fsPath, _this.settings.root, fileDecl)));
                                            }
                                        }
                                    }
                                    // Process each key by each manifest builder.
                                    Object.keys(partial).forEach(function (key) {
                                        var isOverridePartial = partials.length - 1 === partialIndex && overridesProvided;
                                        if (partial[key] !== undefined && (partial[key] !== null || isOverridePartial)) {
                                            // Notify each manifest builder of the key/value pair
                                            _this.manifestBuilders.forEach(function (builder) {
                                                builder.processKey(key, partial[key], isOverridePartial);
                                            });
                                        }
                                    });
                                });
                                // Generate localization resources
                                var locPrepper = new loc.LocPrep.LocKeyGenerator(_this.manifestBuilders);
                                var resources = locPrepper.generateLocalizationKeys();
                                // Build up resource data by reading the translations from disk
                                return _this.buildResourcesData().then(function (resourceData) {
                                    if (resourceData) {
                                        resourceData["defaults"] = resources.combined;
                                    }
                                    // Build up a master file list
                                    var packageFiles = {};
                                    _this.manifestBuilders.forEach(function (builder) {
                                        _.assign(packageFiles, builder.files);
                                    });
                                    var components = { builders: _this.manifestBuilders, resources: resources };
                                    // Finalize each builder
                                    return Promise.all([updateVersionPromise].concat(_this.manifestBuilders.map(function (b) { return b.finalize(packageFiles, resourceData, _this.manifestBuilders); }))).then(function () {
                                        // const the composer do validation
                                        return _this.extensionComposer.validate(components).then(function (validationResult) {
                                            if (validationResult.length === 0 || _this.settings.bypassValidation) {
                                                return components;
                                            }
                                            else {
                                                throw new Error("There were errors with your extension. Address the following and re-run the tool.\n" +
                                                    validationResult);
                                            }
                                        });
                                    });
                                });
                            })];
                }
            });
        });
    };
    /**
     * For each folder F under the localization folder (--loc-root),
     * look for a resources.resjson file within F. If it exists, split the
     * resources.resjson into one file per manifest. Add
     * each to the vsix archive as F/<manifest_loc_path> and F/Extension.vsixlangpack
     */
    Merger.prototype.buildResourcesData = function () {
        // Make sure locRoot is set, that it refers to a directory, and
        // iterate each subdirectory of that.
        if (!this.settings.locRoot) {
            return Promise.resolve(null);
        }
        var stringsPath = path.resolve(this.settings.locRoot);
        var data = { defaults: null };
        // Check that --loc-root exists and is a directory.
        return fsUtils_1.exists(stringsPath)
            .then(function (exists) {
            if (exists) {
                return util_1.promisify(fs_1.lstat)(stringsPath).then(function (stats) {
                    if (stats.isDirectory()) {
                        return true;
                    }
                });
            }
            else {
                return Promise.resolve(false);
            }
        })
            .then(function (stringsFolderExists) {
            if (!stringsFolderExists) {
                return Promise.resolve(null);
            }
            // stringsPath exists and is a directory - read it.
            return util_1.promisify(fs_1.readdir)(stringsPath).then(function (files) {
                var promises = [];
                files.forEach(function (languageTag) {
                    var filePath = path.join(stringsPath, languageTag);
                    var promise = util_1.promisify(fs_1.lstat)(filePath).then(function (fileStats) {
                        if (fileStats.isDirectory()) {
                            // We're under a language tag directory within locRoot. Look for
                            // resources.resjson and use that to generate manfiest files
                            var resourcePath_1 = path.join(filePath, "resources.resjson");
                            return fsUtils_1.exists(resourcePath_1).then(function (exists) {
                                if (exists) {
                                    // A resources.resjson file exists in <locRoot>/<language_tag>/
                                    return util_1.promisify(fs_1.readFile)(resourcePath_1, "utf8").then(function (contents) {
                                        var resourcesObj = JSON.parse(contents);
                                        data[languageTag] = resourcesObj;
                                    });
                                }
                            });
                        }
                    });
                    promises.push(promise);
                });
                return Promise.all(promises);
            });
        })
            .then(function () {
            return data;
        });
    };
    /**
     * Recursively converts a given path to a flat list of FileDeclaration
     * @TODO: Async.
     */
    Merger.prototype.pathToFileDeclarations = function (fsPath, root, fileDecl) {
        var _this = this;
        var files = [];
        if (fs.lstatSync(fsPath).isDirectory()) {
            trace.debug("Path '%s` is a directory. Adding all contained files (recursive).", fsPath);
            fs.readdirSync(fsPath).forEach(function (dirChildPath) {
                trace.debug("-- %s", dirChildPath);
                files = files.concat(_this.pathToFileDeclarations(path.join(fsPath, dirChildPath), root, fileDecl));
            });
        }
        else {
            var relativePath_1 = path.relative(root, fsPath);
            var partName = "/" + relativePath_1;
            if (fileDecl.partName || fileDecl.packagePath) {
                partName = fileDecl.partName || fileDecl.packagePath;
                if (typeof partName === "string") {
                    partName = utils_1.toZipItemName(utils_1.forwardSlashesPath(_.trimEnd(partName, "/") + relativePath_1.substr(fileDecl.path.length)));
                }
                else {
                    partName = partName.map(function (pn) {
                        return utils_1.toZipItemName(utils_1.forwardSlashesPath(_.trimEnd(pn, "/") + relativePath_1.substr(fileDecl.path.length)));
                    });
                }
            }
            files.push({
                path: relativePath_1,
                partName: partName,
                auto: true,
                addressable: fileDecl.addressable,
            });
        }
        return files;
    };
    return Merger;
}());
exports.Merger = Merger;
//# sourceMappingURL=merger.js.map